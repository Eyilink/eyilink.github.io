<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Introduction to Stack-Based Buffer Overflow on x86 Architecture</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fb;
      color: #333;
    }

    h1, h2, h3 {
      color: #1a1a1a;
    }

    h1 {
      text-align: center;
      font-size: 2.2em;
      margin-bottom: 10px;
    }

    h2 {
      margin-top: 40px;
      font-size: 1.8em;
      border-bottom: 2px solid #0077cc;
      padding-bottom: 10px;
    }

    h3 {
      margin-top: 30px;
      font-size: 1.4em;
      color: #0077cc;
    }

    p {
      font-size: 1.1em;
      line-height: 1.6;
      text-align: justify;
    }

    ul, ol {
      font-size: 1.1em;
      line-height: 1.6;
      margin-left: 20px;
    }

    li {
      margin: 10px 0;
    }

    code {
      background-color: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.95em;
    }

    pre {
      background-color: #f4f4f4;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      border-left: 4px solid #0077cc;
    }

    pre code {
      background-color: transparent;
      padding: 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    table th, table td {
      padding: 12px;
      text-align: left;
      border: 1px solid #ddd;
    }

    table th {
      background-color: #0077cc;
      color: white;
      font-weight: bold;
    }

    .note {
      background-color: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 20px 0;
      border-radius: 5px;
    }

    .back-link {
      display: inline-block;
      margin-top: 40px;
      padding: 10px 20px;
      background-color: #0077cc;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      transition: background-color 0.2s;
    }

    .back-link:hover {
      background-color: #005fa3;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 20px auto;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    strong {
      color: #1a1a1a;
    }
  </style>
</head>
<body>
  <h1>Introduction to Stack-Based Buffer Overflow on x86 Architecture</h1>

  <h2>Abstract</h2>
  <p><strong>Summary:</strong></p>
  <ol>
    <li>Getting started with Assembly</li>
    <li>Difference between x64 and x86 architectures</li>
    <li>Memory segmentation during runtime</li>
    <li>Setting up a compiler and a debugger</li>
    <li>C code basics</li>
    <li>Disabling Address Space Layout Randomization (ASLR)</li>
    <li>Example 1: Stack-based buffer overflow by overriding a local variable</li>
    <li>Example 2: Stack-based buffer overflow by overriding a function's return address</li>
    <li>Exercise: Enable ASLR and automate the buffer overflow exploitation</li>
  </ol>

  <h2>Introduction</h2>
  <p>In this article, we will explore buffer overflow vulnerabilities that are present in binaries from the early days. The goal of this article is to go over the basics of low-level programming and examine in detail how a program in runtime works using the C language.</p>
  <p>First, we will see how we can understand compiled code, then the next section will present C language programing basics. Finally, we will analyze C code examples and try to exploit them.</p>

  <h2>I. Getting Started with Assembly</h2>
  <p>Assembly is a low-level programing language that represents the lowest programing language close to machine language that is readable by humans. With most tools, when a compiled program is disassembled, it turns machine code (bytes) into assembly language.</p>
  <p>Assembly language can have multiple syntax, in this article we will only use the Intel syntax, it is considered more readable.</p>
  <p>A running program is composed of memory addresses, and those memory addresses contain our program instructions and variables.</p>
  <p>Here is a code snippet of a disassembled simple program with <code>objdump</code>:</p>
  <pre><code>objdump -M intel -D a.out | grep -A10 main.:

0000118d &lt;main&gt;:
118d: 8d 4c 24 04 lea ecx,[esp+0x4]
1191: 83 e4 f0 and esp,0xfffffff0
1194: ff 71 fc push DWORD PTR [ecx-0x4]
1197: 55 push ebp
1198: 89 e5 mov ebp,esp
119a: 53 push ebx
119b: 51 push ecx
119c: e8 28 00 00 00 call 11c9 &lt;__x86.get_pc_thunk.ax&gt;
11a1: 05 53 2e 00 00 add eax,0x2e53
11a6: 83 ec 0c sub esp,0xc</code></pre>

  <p>This program is a simple <em>Hello World</em> written in C. On the left, we can notice the memory addresses of each instruction in our program which are written in hexadecimal. In the middle, we have the translation in hexadecimal of our instructions. On the right, we have all our instructions written in Assembly language.</p>
  <p>The instructions in Assembly language follow this format:</p>
  <pre><code>operation &lt;destination&gt;,&lt;source&gt;</code></pre>
  <p>The values of destination and source can either be a value, an address or a register.</p>
  <p>So, each instruction contains a source and destination. Each instruction describes an operation, which is the action taken from the source towards the destination.</p>
  <p>In this article, we will only focus on those operations:</p>

  <table>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>mov &lt;destination&gt;,&lt;source&gt;</code></td>
        <td>Transfer the value of the source to the destination.</td>
      </tr>
      <tr>
        <td><code>sub &lt;destination&gt;,&lt;source&gt;</code></td>
        <td>Substract the value of the source to the destination.</td>
      </tr>
      <tr>
        <td><code>inc &lt;destination&gt;</code></td>
        <td>Increment the value of the destination by 1. This instruction only takes the destination as an argument.</td>
      </tr>
      <tr>
        <td><code>cmp &lt;destination&gt;,&lt;source&gt;</code></td>
        <td>Compares the destination from the source by substracting them, it stores the results in flags.</td>
      </tr>
      <tr>
        <td><code>jmp &lt;destination&gt;</code></td>
        <td>Performs un unconditional jump to the address (in hexa) specified in destination.</td>
      </tr>
      <tr>
        <td><code>jle &lt;destination&gt;</code></td>
        <td>Performs a conditional jump if less or equal based on the previous cmp instruction result. It is always preceded by a cmp instruction.</td>
      </tr>
      <tr>
        <td><code>lea &lt;destination_register&gt;,&lt;source&gt;</code></td>
        <td>Loads the effective address of the source into the specified destination register.</td>
      </tr>
    </tbody>
  </table>

  <p>So, we have been talking about registers but as far we didn't explain them.</p>
  <p>A register is a small and very fast storage inside a processor that is used to hold data temporarily during processing. Registers are vital for the execution of a compiled program.</p>
  <p>A lot of registers exist, but we will only focus on some of them.</p>
  <p>The first register we will talk about is the <em>Instruction Pointer</em> register (EIP). It holds the memory address of the instruction to be executed, effectively tracking where the program is currently executing.</p>
  <p><em>[Figure 1: EIP memory address - image placeholder]</em></p>
  <p>For example, in this simple <em>Hello World</em> program, if we place a breakpoint at line number 4 which will stop the program just before this instruction. We can see that the next executed instruction will be at the <code>0x565561a6</code> memory address.</p>
  <p>There are four other registers that are used as temporary variables and are respectively named:</p>

  <table>
    <thead>
      <tr>
        <th>EAX</th>
        <th>ECX</th>
        <th>EDX</th>
        <th>EBX</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Accumulator</td>
        <td>Counter</td>
        <td>Data</td>
        <td>Base</td>
      </tr>
    </tbody>
  </table>

  <p>Those are general purposed registers:</p>
  <ul>
    <li><strong>EAX:</strong> used for arithmetic operations, return values for function calls.</li>
    <li><strong>ECX:</strong> used for loops and string operations as a counter.</li>
    <li><strong>EDX:</strong> used with EAX for some arithmetic operations like multiplication and division, and also used for I/O instructions.</li>
    <li><strong>EBX:</strong> is often used to hold the starting address of an array.</li>
  </ul>
  <p>In this article, we will assume those registers are only used as temporary variables to store values for a certain time.</p>
  <p>So, to recapitulate for a program to run we need the program to be loaded somewhere in memory, and this program needs to be composed of instruction the machine understand. And finally, in runtime, we need registers to compute our program instructions.</p>

  <h2>II. Difference Between x64 and x86 Architectures</h2>
  <p>There are multiple types of processors that exist like for example AMD or ARM processors. Each processor has its own machine language, that's why we compile program for a certain type of processor with a specific architecture. Once a program is compiled, it is a binary and can be standalone.</p>
  <p>Processors come in different sizes, in this section we will only focus on 32 bits and 64 bits processors.</p>
  <p>An Intel x86 processor is a 32 bits processor. Therefore, it can have 2<sup>32</sup> possible addresses, which is around 4 billion addresses.</p>
  <p>The new processors running on 64 bits can have 2<sup>64</sup> possible addresses. Those processors can run in a 32 bits mode that allows them to run faster than classical 32 bits processors.</p>
  <p>The term x86 architecture usually refers to 32 bits architecture.</p>
  <p>We now have to talk about <em>Little Endian</em> and <em>Big Endian</em> because x86 architecture uses <em>Little Endian.</em></p>
  <p>For example, if we take the decimal number <em>9 499 938</em> that can be represented by 3 bytes:</p>
  <pre><code>100100001111010100100010</code></pre>
  <p>In this current configuration, this is in the <em>Big Endian</em> format.</p>
  <p>Now, the <em>Little Endian</em> format reverses the <em>Most significant Byte (MSB)</em> and the <em>Least Significant Byte (LSB)</em>. Here the MSB is <code>10010000</code> and the LSB is <code>00100010.</code></p>
  <p>So if we take the previous <em>9 499 938</em> decimal number in the <em>Little Endian</em> format:</p>
  <pre><code>001000101111010110010000</code></pre>
  <p>As demonstrated by the example, the MSB is stored first and that's how x86 stores values in memory.</p>
  <div class="note">
    <strong>Note:</strong> Later in the article, we will use the GDB debugger to disassemble an x86 compiled program. GDB automatically displays 4 bytes values in a <em>Big Endian</em> format. A 4 bytes value is called a Word. However, if we examine a Word, 2 bytes per 2 bytes it will use the <em>Little Endian</em> format.
  </div>

  <h2>III. Memory Segmentation During Runtime</h2>
  <p>When a program runs, the Operating System will allocate a part of its memory to run this program.</p>
  <p>The memory of a compiled program is divided into five segments called <em>Text</em>, <em>Data</em>, <em>Bss</em>, <em>Heap</em> and the <em>Stack</em> segment.</p>
  <p>The <em>Text</em> segment is where the code is contained in memory. The EIP register is placed at the beginning of this segment when the program is started. This segment is fixed size and Read-Only.</p>
  <p>Each segment is composed of memory addresses, when we talk about the size of the segments, it is intended to mean the number of addresses contained in this segment.</p>
  <p>The <em>Data</em> segment is also fixed size but is writable. This segment is composed of static and global initialized variables. For example:</p>
  <pre><code>static int var = 0;</code></pre>
  <p>The <em>Bss</em> segment is of fixed size and writable. This segment is composed of static and global uninitialized variables. For example:</p>
  <pre><code>static int uninit_var;</code></pre>
  <p>The <em>Heap</em> segment can vary in size. The developer can allocate or free memory in this segment via the <code>malloc</code> and <code>free</code> C functions. The expansion of the <em>Heap</em> goes towards higher memory addresses.</p>
  <p>The <em>Stack</em> segment can also vary in size and is used to store stack frames. For each function in the program there is a corresponding stack frame. Each stack frame stores the local function variables, the passed variables as arguments and the function context notably the return address in order to restore the EIP register to the next instruction after the function is executed.</p>
  <p>The <em>Stack</em> segment implements a stack structure, so it is organized in a First In Last Out (FILO) order. So, the first instruction to be pushed in the <em>Stack</em> will be executed last.</p>
  <p>The <em>Stack</em> grows towards lower memory addresses. The following figure resumes memory segmentation:</p>
  <p><em>[Figure: Memory segmentation diagram - image placeholder]</em></p>

  <h2>IV. Setting Up a Compiler and a Debugger</h2>
  <p>For example, in the next sections, we will need a compiler that is compiling for a 32 bits target architecture. We will also need a debugger that is set in Intel syntax.</p>
  <p>To do so, we can setup a Debian virtual machine and install the following packages using the APT manager:</p>
  <pre><code>sudo apt install -y gdb gcc-multilib g++-multilib libc6-dev-i386</code></pre>
  <p>After this, we will be able to use the <code>gcc</code> compiler and the <code>gdb</code> debugger.</p>
  <p>The command below will let us compile a program:</p>
  <pre><code>gcc -m32 -g myprogram.c</code></pre>
  <p>The <code>-m32</code> argument is used to tell the compiler that our target architecture is 32 bits.</p>
  <p>The <code>-g</code> argument is to tell the compiler to include debugging options.</p>
  <p>The <code>gcc</code> compiler will produce a <code>.out</code> file that is the executable binary.</p>
  <p>Now, we need to use a debugger to examine our binary during runtime:</p>
  <pre><code>gdb -q myprogram.out</code></pre>
  <p>The <code>-q</code> argument here is to enable quiet mode and to suppress GDB startup messages and banner.</p>
  <p>GDB has some useful commands:</p>

  <table>
    <thead>
      <tr>
        <th>Command</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>set disassembly intel</code></td>
        <td>Enable the Intel syntax.</td>
      </tr>
      <tr>
        <td><code>list 1</code></td>
        <td>List the C code from the 1st line.</td>
      </tr>
      <tr>
        <td><code>disassemble main</code></td>
        <td>Disassemble main into Assembly code.</td>
      </tr>
      <tr>
        <td><code>disassemble &lt;function&gt;</code></td>
        <td>Disassemble a specific function.</td>
      </tr>
      <tr>
        <td><code>break &lt;line_number&gt;</code></td>
        <td>Set a breakpoint at a certain line number. The program will stop right before the execution of this line. This will allow us to examine the binary in a certain state.</td>
      </tr>
      <tr>
        <td><code>run &lt;arguments&gt;</code></td>
        <td>Run the binary. One or multiple arguments can be passed.</td>
      </tr>
      <tr>
        <td><code>continue</code></td>
        <td>Continue the execution of the binary after the breakpoint.</td>
      </tr>
      <tr>
        <td><code>nexti</code></td>
        <td>Step to the next Assembly instruction.</td>
      </tr>
      <tr>
        <td><code>info register &lt;register&gt;</code></td>
        <td>Examine a register.</td>
      </tr>
      <tr>
        <td><code>print &lt;address1&gt; - &lt;address2&gt;</code></td>
        <td>Print in decimal the distance between two memory addresses.</td>
      </tr>
      <tr>
        <td><code>x/i &lt;address&gt;</code></td>
        <td>Examine the instruction at a specific address.</td>
      </tr>
      <tr>
        <td><code>x/xw &lt;address&gt;</code></td>
        <td>Examine a Word (4 bytes) in hexadecimal at a specific address.</td>
      </tr>
      <tr>
        <td><code>x/sw &lt;address&gt;</code></td>
        <td>Examine a Word in ASCII at a specific address. This is used to display strings.</td>
      </tr>
    </tbody>
  </table>

  <p>These commands will be demonstrated in the example sections.</p>

  <h2>V. C Code Basics</h2>
  <p>In this section, we will go through basic structures provided natively in C.</p>
  <p>The first structure is strings in C which are used to store characters. A string is typically an array that is of a specific type: a string is a character array.</p>
  <p>But what is an array then. An array is N contiguous elements in memory. Contiguous means that there is one element after the other. An array finishes by a null byte (0x00) to specify that it is the end of this array. Arrays are also called buffers.</p>
  <p>C language also provides native types. The important thing to grasp is that each type has a size in bytes.</p>
  <p>The figure below displays the number of bytes, each type takes in memory:</p>
  <p><em>[Figure: C data types and sizes - image placeholder]</em></p>
  <p>This will be important to remember when we will try to overflow other values at other memory addresses.</p>
  <p>So the important thing to understand is that when you declare a variable of a specified type, a space in memory is allocated for that variable using the size described by the type it implements.</p>
  <p>Therefore, if you set the value of this variable with something bigger than its originally allocated space it will overflow in the next memory spaces.</p>
  <p>C code implements <em>pointers</em> that are used to allocate or free memory in the <em>Heap</em>. A <em>pointer</em> is used to freely manipulate memory. A <em>pointer</em> points to the allocated memory.</p>
  <p>To declare a <em>pointer</em>, we must use the following syntax:</p>
  <pre><code>void *mypointer;</code></pre>
  <p>Then, to allocate space to this pointer we can use the <code>malloc</code> function:</p>
  <pre><code>mypointer = (void *)malloc(4); // This will allocate 4 bytes</code></pre>
  <p>For example, here we can store an int but if we want to store a long long int which is 8 bytes, then 4 bytes will overflow in the next memory space in the <em>Heap</em>.</p>
  <p>The <code>free</code> function is used to free this space, this function will be shown in the examples.</p>
  <p>There are several operators used with pointers: the asterisk (*) operator and the unary (&) operator.</p>
  <p>The asterisk (*) operator is used to display the value of the address where a pointer points.</p>
  <p>The unary (&) operator will point to the real address of the pointer on the <em>Stack</em>.</p>
  <p>The example below illustrates operations on pointers:</p>
  <pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(){
  void* p;
  p=malloc(4);
  *(int *)p = 15555;
  
  if(p==NULL){
    printf("Memory allocation failed\n");
    return 1;
  }
  
  printf("Value where the pointer points using the * operator (*pointer) : %i\n", *(int *)p);
  printf("Address in the Heap where the pointer points using no operator (pointer) : %p\n", p);
  printf("Real address of the pointer variable in the stack using the & operator (&pointer) : %p\n", &p);
  
  free(p);
  return 0;
}</code></pre>

  <p>We can compile it and run it, this will produce the output below:</p>
  <p><em>[Figure: Pointer operations output - image placeholder]</em></p>
  <p>We can see that by allocating four bytes of memory for our pointer we can fill it with an int which is also four bytes.</p>
  <p>We can also note that the address where the pointer points (<em>Heap</em>) is lower in memory than the real address of the pointer (<em>Stack</em>).</p>

  <h2>VI. Disabling Address Space Layout Randomization (ASLR)</h2>
  <p>ASLR is a protection on Operating Systems used to randomize addresses each time we run a program. Therefore, from one run instance to another, addresses won't be the same. This protection is not convenient for us because if we need to make a calculus of space in between two addresses to overflow a buffer and those addresses change from one running instance to another, we won't be able to perform our buffer overflow manually. Thus, we need static addresses.</p>
  <p>In a Debian machine, we can disable ASLR using the command below.</p>
  <pre><code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></pre>

  <h2>VII. Example 1: Stack-Based Buffer Overflow by Overriding a Local Variable</h2>
  <p>In this section, we will tackle the first example of buffer overflow, with the code below:</p>
  <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
  int value = 5;
  char buffer_one[8], buffer_two[8];
  
  strcpy(buffer_one, "one"); /* Put "one" into buffer_one. */
  strcpy(buffer_two, "two"); /* Put "two" into buffer_two. */
  
  printf("[BEFORE] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
  printf("[BEFORE] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
  printf("[BEFORE] value is at %p and is %d (0x%08x)\n", &value, value, value);
  
  printf("\n[STRCPY] copying %d bytes into buffer_two\n\n", strlen(argv[1]));
  strcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two. */
  
  printf("[AFTER] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
  printf("[AFTER] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
  printf("[AFTER] value is at %p and is %d (0x%08x)\n", &value, value, value);
}</code></pre>

  <p>We can compile this code in our Debian machine:</p>
  <pre><code>gcc -m32 -g code.c</code></pre>
  <p>By now, we can understand most of this code. However, there is the <code>argv[1]</code> that we need to explain. Indeed, <code>argv[1]</code> will retrieve the first argument we give when we run our binary, we can run the binary with:</p>
  <pre><code>./a.out three</code></pre>
  <p>If we run the binary, we will notice that it will copy the first argument into <code>buffer_two</code>:</p>
  <p><em>[Figure: Program output with "three" - image placeholder]</em></p>
  <p>Remember that all variables in a function are stored in the <em>Stack</em> in a FILO order, so here we declare the <code>value</code> variable first so it will go to the base of the <em>Stack</em>, then on top <code>buffer_one</code> will go and finally <code>buffer_two</code>.</p>
  <p><em>[Figure: Stack layout diagram - image placeholder]</em></p>
  <p>So here, we know that we can manipulate the data in <code>buffer_two</code> and our goal is to rewrite the <code>value</code> variable. From the schema, we deduce that the <code>value</code> variable is 16 bytes away from the beginning of the <code>buffer_two</code> variable.</p>
  <p>We can confirm this using the GDB debugger and compute the difference between the two addresses of those variables:</p>
  <p><em>[Figure: GDB address calculation - image placeholder]</em></p>
  <p>So, we do know that <code>buffer_two</code> is 16 bytes away from <code>value</code>, and <code>value</code> is 4 bytes, a char is 1 byte then if we want to completely fill <code>value</code> with «ABCD», we will have to put 16 bytes before «ABCD» which translates to adding 16 chars in front of it. The command below can help us accomplish this:</p>
  <pre><code>perl -e 'print "A"x16 . "ABCD"'</code></pre>
  <p>Output: <code>AAAAAAAAAAAAAAAAABCD</code></p>
  <p>If we run the program with this string in argument, we will notice that <code>value</code> is overflowed:</p>
  <p><em>[Figure: Overflowed value output - image placeholder]</em></p>
  <p>Here, we can see that <code>value</code> is overflowed with <code>0x44434241</code> which is the representation of a char in ASCII. We shouldn't forget that those bytes are actually stored in <em>Little Endian</em> so what it is really stored is reversed, it gives <code>0x41 0x42 0x43 0x44</code> which if we translate each bytes in ASCII gives <em>A B C D</em>. We can use GDB to see it clearly:</p>
  <p><em>[Figure: GDB memory view - image placeholder]</em></p>
  <p>This is all for this part, we explored how to overflow a variable near in memory. In the next part, we will overflow the return address of a local function.</p>

  <h2>VIII. Example 2: Heap-Based Buffer Overflow by Overriding a Variable</h2>
  <p>In this section, we will tackle the first example of buffer overflow, with the code below:</p>
  <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
  char * buffer;
  char * condition;
  
  buffer = malloc(100);
  condition = malloc(20);
  
  strcpy(buffer, argv[1]);
  
  printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
  printf("[DEBUG] condition @ %p: \'%s\'\n", condition, condition);
  
  if(strcmp(condition, "TRUE") ==