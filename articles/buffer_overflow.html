<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Introduction to Stack-Based Buffer Overflow on x86 Architecture</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f7fa;
      color: #2c3e50;
      line-height: 1.6;
    }

    /* Sidebar Navigation */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 280px;
      height: 100vh;
      background: #fafafa;
      padding: 30px 20px;
      overflow-y: auto;
      border-right: 1px solid #e0e0e0;
      z-index: 1000;
    }

    .sidebar h3 {
      color: #1a1a1a;
      font-size: 1.1em;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e0e0e0;
      font-weight: 600;
    }

    .sidebar nav ul {
      list-style: none;
    }

    .sidebar nav li {
      margin: 0;
    }

    .sidebar nav a {
      display: block;
      color: #4a4a4a;
      text-decoration: none;
      padding: 10px 15px;
      transition: all 0.2s ease;
      font-size: 0.95em;
      border-left: 2px solid transparent;
    }

    .sidebar nav a:hover {
      color: #000;
      background: #f0f0f0;
      border-left: 2px solid #000;
    }

    .sidebar nav a.active {
      background: #f0f0f0;
      color: #000;
      font-weight: 600;
      border-left: 2px solid #000;
    }

    .sidebar nav ul ul {
      margin-left: 15px;
      margin-top: 5px;
    }

    .sidebar nav ul ul a {
      font-size: 0.88em;
      color: #666;
      padding: 8px 12px;
    }

    .back-home {
      display: block;
      margin-top: 30px;
      padding: 12px 20px;
      background: #000;
      color: #fff;
      text-align: center;
      text-decoration: none;
      transition: all 0.2s ease;
      border: 1px solid #000;
    }

    .back-home:hover {
      background: #333;
      border-color: #333;
    }

    /* Main Content */
    .content {
      margin-left: 280px;
      padding: 40px 60px;
      max-width: 1200px;
    }

    /* Article Header */
    .article-header {
      background: #fff;
      padding: 40px;
      margin-bottom: 40px;
      border-bottom: 2px solid #000;
    }

    .article-header h1 {
      color: #000;
      font-size: 2.5em;
      margin-bottom: 15px;
      font-weight: 700;
    }

    .article-meta {
      display: flex;
      gap: 20px;
      color: #666;
      font-size: 0.95em;
      margin-top: 15px;
      font-style: italic;
    }

    .article-meta span {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    /* Sections */
    section {
      background: #fff;
      padding: 35px 40px;
      margin-bottom: 30px;
      border: 1px solid #e0e0e0;
    }

    h2 {
      color: #000;
      font-size: 2em;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #000;
      font-weight: 700;
    }

    h3 {
      color: #1a1a1a;
      font-size: 1.5em;
      margin-top: 30px;
      margin-bottom: 15px;
      font-weight: 600;
    }

    p {
      font-size: 1.05em;
      line-height: 1.8;
      margin-bottom: 15px;
      color: #34495e;
      text-align: justify;
    }

    /* Lists */
    ul, ol {
      font-size: 1.05em;
      line-height: 1.8;
      margin: 20px 0;
      padding-left: 25px;
    }

    li {
      margin: 12px 0;
      color: #34495e;
    }

    li strong {
      color: #1a1a1a;
    }

    /* Code blocks */
    code {
      background-color: #f5f5f5;
      padding: 3px 8px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.92em;
      color: #000;
      border: 1px solid #e0e0e0;
    }

    pre {
      background: #f9f9f9;
      padding: 20px;
      border: 1px solid #e0e0e0;
      border-left: 3px solid #000;
      overflow-x: auto;
      margin: 20px 0;
    }

    pre code {
      background: transparent;
      padding: 0;
      border: none;
      color: #000;
      font-size: 0.95em;
      line-height: 1.6;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 25px 0;
      background-color: #fff;
      border: 1px solid #e0e0e0;
    }

    table th {
      background: #000;
      color: white;
      font-weight: 600;
      padding: 15px;
      text-align: left;
      font-size: 1.05em;
    }

    table td {
      padding: 15px;
      border-bottom: 1px solid #e0e0e0;
      color: #2c3e50;
    }

    table tr:last-child td {
      border-bottom: none;
    }

    table tr:hover {
      background-color: #fafafa;
    }

    /* Note boxes */
    .note {
      background: #f9f9f9;
      border-left: 4px solid #000;
      padding: 20px;
      margin: 25px 0;
      border: 1px solid #e0e0e0;
      border-left: 4px solid #000;
    }

    .note strong {
      color: #000;
      font-size: 1.1em;
      display: block;
      margin-bottom: 8px;
    }

    /* Images */
    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 30px auto;
      border: 1px solid #e0e0e0;
    }

    /* Links */
    a {
      color: #000;
      text-decoration: underline;
      font-weight: 500;
      transition: color 0.2s ease;
    }

    a:hover {
      color: #666;
    }

    /* Abstract section special styling */
    .abstract {
      background: #fafafa;
      border-left: 4px solid #000;
    }

    .abstract ol {
      background: #fff;
      padding: 20px 20px 20px 45px;
      border: 1px solid #e0e0e0;
      margin-top: 15px;
    }

    /* Responsive */
    @media (max-width: 968px) {
      .sidebar {
        transform: translateX(-280px);
        transition: transform 0.3s ease;
      }

      .sidebar.active {
        transform: translateX(0);
      }

      .content {
        margin-left: 0;
        padding: 20px;
      }

      .article-header {
        padding: 25px;
      }

      section {
        padding: 25px;
      }
    }

    /* Scroll to top button */
    .scroll-top {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: #000;
      color: white;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s ease;
      border: 1px solid #000;
      text-decoration: none;
      font-size: 1.5em;
    }

    .scroll-top.visible {
      opacity: 1;
    }

    .scroll-top:hover {
      background: #333;
      border-color: #333;
    }
  </style>
</head>
<body>
  <!-- Sidebar Navigation -->
  <aside class="sidebar">
    <h3>Table of Contents</h3>
    <nav>
      <ul>
        <li><a href="#abstract">Abstract</a></li>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#assembly">I. Getting Started with Assembly</a></li>
        <li><a href="#architecture">II. x64 vs x86 Architectures</a></li>
        <li><a href="#memory">III. Memory Segmentation</a></li>
        <li><a href="#setup">IV. Compiler and Debugger Setup</a></li>
        <li><a href="#c-basics">V. C Code Basics</a></li>
        <li><a href="#aslr">VI. Disabling ASLR</a></li>
        <li>
          <a href="#example1">VII. Example 1: Stack Overflow</a>
        </li>
        <li>
          <a href="#example2">VIII. Example 2: Heap Overflow</a>
        </li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </nav>
    <a href="../index.html" class="back-home">‚Üê Back to Blog</a>
  </aside>

  <!-- Main Content -->
  <div class="content">
    <!-- Article Header -->
    <div class="article-header">
      <h1>Introduction to Stack-Based Buffer Overflow on x86 Architecture</h1>
      <div class="article-meta">
        <span>Research Article</span>
        <span>|</span>
        <span>Low-Level Programming</span>
        <span>|</span>
        <span>20 min read</span>
      </div>
    </div>

    <!-- Abstract -->
    <section id="abstract" class="abstract">
      <h2>Abstract</h2>
      <p><strong>Summary:</strong></p>
      <ol>
        <li>Getting started with Assembly</li>
        <li>Difference between x64 and x86 architectures</li>
        <li>Memory segmentation during runtime</li>
        <li>Setting up a compiler and a debugger</li>
        <li>C code basics</li>
        <li>Disabling Address Space Layout Randomization (ASLR)</li>
        <li>Example 1: Stack-based buffer overflow by overriding a local variable</li>
        <li>Example 2: Stack-based buffer overflow by overriding a function's return address</li>
        <li>Exercise: Enable ASLR and automate the buffer overflow exploitation</li>
      </ol>
    </section>

    <!-- Introduction -->
    <section id="introduction">
      <h2>Introduction</h2>
      <p>In this article, we will explore buffer overflow vulnerabilities that are present in binaries from the early days. The goal of this article is to go over the basics of low-level programming and examine in detail how a program in runtime works using the C language.</p>
      <p>First, we will see how we can understand compiled code, then the next section will present C language programing basics. Finally, we will analyze C code examples and try to exploit them.</p>
    </section>

    <!-- Assembly -->
    <section id="assembly">
      <h2>I. Getting Started with Assembly</h2>
      <p>Assembly is a low-level programing language that represents the lowest programing language close to machine language that is readable by humans. With most tools, when a compiled program is disassembled, it turns machine code (bytes) into assembly language.</p>
      <p>Assembly language can have multiple syntax, in this article we will only use the Intel syntax, it is considered more readable.</p>
      <p>A running program is composed of memory addresses, and those memory addresses contain our program instructions and variables.</p>
      <p>Here is a code snippet of a disassembled simple program with <code>objdump</code>:</p>
      <pre><code>objdump -M intel -D a.out | grep -A10 main.:

0000118d &lt;main&gt;:
118d: 8d 4c 24 04 lea ecx,[esp+0x4]
1191: 83 e4 f0 and esp,0xfffffff0
1194: ff 71 fc push DWORD PTR [ecx-0x4]
1197: 55 push ebp
1198: 89 e5 mov ebp,esp
119a: 53 push ebx
119b: 51 push ecx
119c: e8 28 00 00 00 call 11c9 &lt;__x86.get_pc_thunk.ax&gt;
11a1: 05 53 2e 00 00 add eax,0x2e53
11a6: 83 ec 0c sub esp,0xc</code></pre>

      <p>This program is a simple <em>Hello World</em> written in C. On the left, we can notice the memory addresses of each instruction in our program which are written in hexadecimal. In the middle, we have the translation in hexadecimal of our instructions. On the right, we have all our instructions written in Assembly language.</p>
      <p>The instructions in Assembly language follow this format:</p>
      <pre><code>operation &lt;destination&gt;,&lt;source&gt;</code></pre>
      <p>The values of destination and source can either be a value, an address or a register.</p>
      <p>So, each instruction contains a source and destination. Each instruction describes an operation, which is the action taken from the source towards the destination.</p>
      <p>In this article, we will only focus on those operations:</p>

      <table>
        <thead>
          <tr>
            <th>Operation</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>mov &lt;destination&gt;,&lt;source&gt;</code></td>
            <td>Transfer the value of the source to the destination.</td>
          </tr>
          <tr>
            <td><code>sub &lt;destination&gt;,&lt;source&gt;</code></td>
            <td>Substract the value of the source to the destination.</td>
          </tr>
          <tr>
            <td><code>inc &lt;destination&gt;</code></td>
            <td>Increment the value of the destination by 1. This instruction only takes the destination as an argument.</td>
          </tr>
          <tr>
            <td><code>cmp &lt;destination&gt;,&lt;source&gt;</code></td>
            <td>Compares the destination from the source by substracting them, it stores the results in flags.</td>
          </tr>
          <tr>
            <td><code>jmp &lt;destination&gt;</code></td>
            <td>Performs un unconditional jump to the address (in hexa) specified in destination.</td>
          </tr>
          <tr>
            <td><code>jle &lt;destination&gt;</code></td>
            <td>Performs a conditional jump if less or equal based on the previous cmp instruction result. It is always preceded by a cmp instruction.</td>
          </tr>
          <tr>
            <td><code>lea &lt;destination_register&gt;,&lt;source&gt;</code></td>
            <td>Loads the effective address of the source into the specified destination register.</td>
          </tr>
        </tbody>
      </table>

      <p>So, we have been talking about registers but as far we didn't explain them.</p>
      <p>A register is a small and very fast storage inside a processor that is used to hold data temporarily during processing. Registers are vital for the execution of a compiled program.</p>
      <p>A lot of registers exist, but we will only focus on some of them.</p>
      <p>The first register we will talk about is the <em>Instruction Pointer</em> register (EIP). It holds the memory address of the instruction to be executed, effectively tracking where the program is currently executing.</p>
      <img src="images_buffer_overflow/image1.png" alt="EIP Register">
      <p>For example, in this simple <em>Hello World</em> program, if we place a breakpoint at line number 4 which will stop the program just before this instruction. We can see that the next executed instruction will be at the <code>0x565561a6</code> memory address.</p>
      <p>There are four other registers that are used as temporary variables and are respectively named:</p>

      <table>
        <thead>
          <tr>
            <th>EAX</th>
            <th>ECX</th>
            <th>EDX</th>
            <th>EBX</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Accumulator</td>
            <td>Counter</td>
            <td>Data</td>
            <td>Base</td>
          </tr>
        </tbody>
      </table>

      <p>Those are general purposed registers:</p>
      <ul>
        <li><strong>EAX:</strong> used for arithmetic operations, return values for function calls.</li>
        <li><strong>ECX:</strong> used for loops and string operations as a counter.</li>
        <li><strong>EDX:</strong> used with EAX for some arithmetic operations like multiplication and division, and also used for I/O instructions.</li>
        <li><strong>EBX:</strong> is often used to hold the starting address of an array.</li>
      </ul>
      <p>In this article, we will assume those registers are only used as temporary variables to store values for a certain time.</p>
      <p>So, to recapitulate for a program to run we need the program to be loaded somewhere in memory, and this program needs to be composed of instruction the machine understand. And finally, in runtime, we need registers to compute our program instructions.</p>
    </section>

    <!-- Architecture -->
    <section id="architecture">
      <h2>II. Difference Between x64 and x86 Architectures</h2>
      <p>There are multiple types of processors that exist like for example AMD or ARM processors. Each processor has its own machine language, that's why we compile program for a certain type of processor with a specific architecture. Once a program is compiled, it is a binary and can be standalone.</p>
      <p>Processors come in different sizes, in this section we will only focus on 32 bits and 64 bits processors.</p>
      <p>An Intel x86 processor is a 32 bits processor. Therefore, it can have 2<sup>32</sup> possible addresses, which is around 4 billion addresses.</p>
      <p>The new processors running on 64 bits can have 2<sup>64</sup> possible addresses. Those processors can run in a 32 bits mode that allows them to run faster than classical 32 bits processors.</p>
      <p>The term x86 architecture usually refers to 32 bits architecture.</p>
      <p>We now have to talk about <em>Little Endian</em> and <em>Big Endian</em> because x86 architecture uses <em>Little Endian.</em></p>
      <p>For example, if we take the decimal number <em>9 499 938</em> that can be represented by 3 bytes:</p>
      <pre><code>100100001111010100100010</code></pre>
      <p>In this current configuration, this is in the <em>Big Endian</em> format.</p>
      <p>Now, the <em>Little Endian</em> format reverses the <em>Most significant Byte (MSB)</em> and the <em>Least Significant Byte (LSB)</em>. Here the MSB is <code>10010000</code> and the LSB is <code>00100010.</code></p>
      <p>So if we take the previous <em>9 499 938</em> decimal number in the <em>Little Endian</em> format:</p>
      <pre><code>001000101111010110010000</code></pre>
      <p>As demonstrated by the example, the MSB is stored first and that's how x86 stores values in memory.</p>
      <div class="note">
        <strong>Note:</strong> Later in the article, we will use the GDB debugger to disassemble an x86 compiled program. GDB automatically displays 4 bytes values in a <em>Big Endian</em> format. A 4 bytes value is called a Word. However, if we examine a Word, 2 bytes per 2 bytes it will use the <em>Little Endian</em> format.
      </div>
    </section>

    <!-- Memory -->
    <section id="memory">
      <h2>III. Memory Segmentation During Runtime</h2>
      <p>When a program runs, the Operating System will allocate a part of its memory to run this program.</p>
      <p>The memory of a compiled program is divided into five segments called <em>Text</em>, <em>Data</em>, <em>Bss</em>, <em>Heap</em> and the <em>Stack</em> segment.</p>
      <p>The <em>Text</em> segment is where the code is contained in memory. The EIP register is placed at the beginning of this segment when the program is started. This segment is fixed size and Read-Only.</p>
      <p>Each segment is composed of memory addresses, when we talk about the size of the segments, it is intended to mean the number of addresses contained in this segment.</p>
      <p>The <em>Data</em> segment is also fixed size but is writable. This segment is composed of static and global initialized variables. For example:</p>
      <pre><code>static int var = 0;</code></pre>
      <p>The <em>Bss</em> segment is of fixed size and writable. This segment is composed of static and global uninitialized variables. For example:</p>
      <pre><code>static int uninit_var;</code></pre>
      <p>The <em>Heap</em> segment can vary in size. The developer can allocate or free memory in this segment via the <code>malloc</code> and <code>free</code> C functions. The expansion of the <em>Heap</em> goes towards higher memory addresses.</p>
      <p>The <em>Stack</em> segment can also vary in size and is used to store stack frames. For each function in the program there is a corresponding stack frame. Each stack frame stores the local function variables, the passed variables as arguments and the function context notably the return address in order to restore the EIP register to the next instruction after the function is executed.</p>
      <p>The <em>Stack</em> segment implements a stack structure, so it is organized in a First In Last Out (FILO) order. So, the first instruction to be pushed in the <em>Stack</em> will be executed last.</p>
      <p>The <em>Stack</em> grows towards lower memory addresses. The following figure resumes memory segmentation:</p>
      <img src="images_buffer_overflow/image2.png" alt="Memory Segmentation">
    </section>

    <!-- Setup -->
    <section id="setup">
      <h2>IV. Setting Up a Compiler and a Debugger</h2>
      <p>For example, in the next sections, we will need a compiler that is compiling for a 32 bits target architecture. We will also need a debugger that is set in Intel syntax.</p>
      <p>To do so, we can setup a Debian virtual machine and install the following packages using the APT manager:</p>
      <pre><code>sudo apt install -y gdb gcc-multilib g++-multilib libc6-dev-i386</code></pre>
      <p>After this, we will be able to use the <code>gcc</code> compiler and the <code>gdb</code> debugger.</p>
      <p>The command below will let us compile a program:</p>
      <pre><code>gcc -m32 -g myprogram.c</code></pre>
      <p>The <code>-m32</code> argument is used to tell the compiler that our target architecture is 32 bits.</p>
      <p>The <code>-g</code> argument is to tell the compiler to include debugging options.</p>
      <p>The <code>gcc</code> compiler will produce a <code>.out</code> file that is the executable binary.</p>
      <p>Now, we need to use a debugger to examine our binary during runtime:</p>
      <pre><code>gdb -q myprogram.out</code></pre>
      <p>The <code>-q</code> argument here is to enable quiet mode and to suppress GDB startup messages and banner.</p>
      <p>GDB has some useful commands:</p>

      <table>
        <thead>
          <tr>
            <th>Command</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>set disassembly intel</code></td>
            <td>Enable the Intel syntax.</td>
          </tr>
          <tr>
            <td><code>list 1</code></td>
            <td>List the C code from the 1st line.</td>
          </tr>
          <tr>
            <td><code>disassemble main</code></td>
            <td>Disassemble main into Assembly code.</td>
          </tr>
          <tr>
            <td><code>disassemble &lt;function&gt;</code></td>
            <td>Disassemble a specific function.</td>
          </tr>
          <tr>
            <td><code>break &lt;line_number&gt;</code></td>
            <td>Set a breakpoint at a certain line number. The program will stop right before the execution of this line. This will allow us to examine the binary in a certain state.</td>
          </tr>
          <tr>
            <td><code>run &lt;arguments&gt;</code></td>
            <td>Run the binary. One or multiple arguments can be passed.</td>
          </tr>
          <tr>
            <td><code>continue</code></td>
            <td>Continue the execution of the binary after the breakpoint.</td>
          </tr>
          <tr>
            <td><code>nexti</code></td>
            <td>Step to the next Assembly instruction.</td>
          </tr>
          <tr>
            <td><code>info register &lt;register&gt;</code></td>
            <td>Examine a register.</td>
          </tr>
          <tr>
            <td><code>print &lt;address1&gt; - &lt;address2&gt;</code></td>
            <td>Print in decimal the distance between two memory addresses.</td>
          </tr>
          <tr>
            <td><code>x/i &lt;address&gt;</code></td>
            <td>Examine the instruction at a specific address.</td>
          </tr>
          <tr>
            <td><code>x/xw &lt;address&gt;</code></td>
            <td>Examine a Word (4 bytes) in hexadecimal at a specific address.</td>
          </tr>
          <tr>
            <td><code>x/sw &lt;address&gt;</code></td>
            <td>Examine a Word in ASCII at a specific address. This is used to display strings.</td>
          </tr>
        </tbody>
      </table>

      <p>These commands will be demonstrated in the example sections.</p>
    </section>

    <!-- C Basics -->
    <section id="c-basics">
      <h2>V. C Code Basics</h2>
      <p>In this section, we will go through basic structures provided natively in C.</p>
      <p>The first structure is strings in C which are used to store characters. A string is typically an array that is of a specific type: a string is a character array.</p>
      <p>But what is an array then. An array is N contiguous elements in memory. Contiguous means that there is one element after the other. An array finishes by a null byte (0x00) to specify that it is the end of this array. Arrays are also called buffers.</p>
      <p>C language also provides native types. The important thing to grasp is that each type has a size in bytes.</p>
      <p>The figure below displays the number of bytes, each type takes in memory:</p>
      <img src="images_buffer_overflow/image3.png" alt="C Data Types">
      <p>This will be important to remember when we will try to overflow other values at other memory addresses.</p>
      <p>So the important thing to understand is that when you declare a variable of a specified type, a space in memory is allocated for that variable using the size described by the type it implements.</p>
      <p>Therefore, if you set the value of this variable with something bigger than its originally allocated space it will overflow in the next memory spaces.</p>
      <p>C code implements <em>pointers</em> that are used to allocate or free memory in the <em>Heap</em>. A <em>pointer</em> is used to freely manipulate memory. A <em>pointer</em> points to the allocated memory.</p>
      <p>To declare a <em>pointer</em>, we must use the following syntax:</p>
      <pre><code>void *mypointer;</code></pre>
      <p>Then, to allocate space to this pointer we can use the <code>malloc</code> function:</p>
      <pre><code>mypointer = (void *)malloc(4); // This will allocate 4 bytes</code></pre>
      <p>For example, here we can store an int but if we want to store a long long int which is 8 bytes, then 4 bytes will overflow in the next memory space in the <em>Heap</em>.</p>
      <p>The <code>free</code> function is used to free this space, this function will be shown in the examples.</p>
      <p>There are several operators used with pointers: the asterisk (*) operator and the unary (&) operator.</p>
      <p>The asterisk (*) operator is used to display the value of the address where a pointer points.</p>
      <p>The